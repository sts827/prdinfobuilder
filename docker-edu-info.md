# Docker & 개발환경 기초 교육 자료

**작성일**: 2026-01-28
**대상**: Docker, 네트워크, 서버, 백엔드 입문자
**목표**: 개념 이해 → 왜 이렇게 동작하는지 납득

---

## 목차

1. [큰 그림: 웹 서비스는 어떻게 동작하는가?](#1-큰-그림-웹-서비스는-어떻게-동작하는가)
2. [네트워크 기초](#2-네트워크-기초)
3. [Docker란 무엇인가?](#3-docker란-무엇인가)
4. [Docker 네트워크](#4-docker-네트워크)
5. [웹서버와 리버스 프록시](#5-웹서버와-리버스-프록시)
6. [개발환경 vs 프로덕션](#6-개발환경-vs-프로덕션)
7. [DevOps 기초 개념](#7-devops-기초-개념)
8. [자주 묻는 질문](#8-자주-묻는-질문)

---

## 1. 큰 그림: 웹 서비스는 어떻게 동작하는가?

### 1.1 가장 단순한 형태

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           웹 서비스의 기본 흐름                               │
└─────────────────────────────────────────────────────────────────────────────┘

    사용자                     인터넷                      서버
   ┌──────┐                                            ┌──────────┐
   │ 브라  │  ──── "naver.com 보여줘" ────────────────▶ │ 웹서버    │
   │ 우저  │                                            │ (Nginx)  │
   │      │  ◀──── HTML/CSS/JS 파일 ─────────────────── │          │
   └──────┘                                            └──────────┘
```

### 1.2 실제 서비스 (복잡한 형태)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           실제 웹 서비스 구조                                 │
└─────────────────────────────────────────────────────────────────────────────┘

사용자 브라우저
     │
     │ 1. DNS 조회: "myapp.com" → 123.45.67.89
     ↓
┌─────────────┐
│   DNS 서버   │  도메인 이름 → IP 주소 변환
└─────────────┘
     │
     ↓
┌─────────────┐
│ 로드밸런서   │  여러 서버에 트래픽 분산 (AWS ALB 등)
└─────────────┘
     │
     ├──────────────────┬──────────────────┐
     ↓                  ↓                  ↓
┌─────────┐        ┌─────────┐        ┌─────────┐
│ Server1 │        │ Server2 │        │ Server3 │
│ (Nginx) │        │ (Nginx) │        │ (Nginx) │
└────┬────┘        └────┬────┘        └────┬────┘
     │                  │                  │
     ↓                  ↓                  ↓
┌─────────┐        ┌─────────┐        ┌─────────┐
│ Next.js │        │ Next.js │        │ Next.js │
│   App   │        │   App   │        │   App   │
└────┬────┘        └────┬────┘        └────┬────┘
     │                  │                  │
     └──────────────────┼──────────────────┘
                        ↓
                  ┌───────────┐
                  │ Database  │  (PostgreSQL, MongoDB 등)
                  └───────────┘
```

### 1.3 핵심 용어 정리

| 용어 | 역할 | 비유 |
|------|------|------|
| **DNS** | 도메인 → IP 변환 | 전화번호부 |
| **로드밸런서** | 트래픽 분산 | 은행 번호표 시스템 |
| **웹서버 (Nginx)** | 정적 파일 제공 + 요청 라우팅 | 안내 데스크 |
| **애플리케이션 서버** | 비즈니스 로직 처리 | 실제 업무 담당자 |
| **데이터베이스** | 데이터 저장 | 서류 보관소 |

---

## 2. 네트워크 기초

### 2.1 IP 주소란?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              IP 주소 = 컴퓨터의 주소                          │
└─────────────────────────────────────────────────────────────────────────────┘

집 주소:     서울시 강남구 테헤란로 123번길 45
IP 주소:     192.168.1.100

인터넷에서 컴퓨터를 찾으려면 IP 주소가 필요함
```

**특수한 IP 주소들**:

| IP 주소 | 의미 | 용도 |
|---------|------|------|
| `127.0.0.1` | 자기 자신 (루프백) | 로컬 테스트 |
| `localhost` | 127.0.0.1의 별명 | 개발 시 사용 |
| `0.0.0.0` | 모든 인터페이스 | 서버 바인딩 |
| `192.168.x.x` | 사설 IP (내부망) | 가정/회사 네트워크 |
| `10.x.x.x` | 사설 IP (내부망) | 회사/클라우드 내부 |

### 2.2 포트(Port)란?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         포트 = 아파트 호수                                    │
└─────────────────────────────────────────────────────────────────────────────┘

IP 주소가 아파트 건물 주소라면,
포트 번호는 몇 호인지를 나타냄

192.168.1.100:3000
└─────┬─────┘ └─┬─┘
   건물주소    호수(포트)
```

**잘 알려진 포트 번호**:

| 포트 | 용도 | 예시 |
|------|------|------|
| 80 | HTTP (웹) | http://example.com (포트 생략됨) |
| 443 | HTTPS (보안 웹) | https://example.com |
| 22 | SSH (원격 접속) | 서버 관리 |
| 3000 | 개발 서버 관례 | Next.js, React 등 |
| 5432 | PostgreSQL | 데이터베이스 |
| 27017 | MongoDB | 데이터베이스 |

### 2.3 바인딩(Binding)이란?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    바인딩 = "이 주소에서 손님을 받겠다"                         │
└─────────────────────────────────────────────────────────────────────────────┘

서버 프로그램이 시작할 때:
"나는 [IP주소]:[포트]에서 요청을 기다리겠다"라고 선언하는 것

┌────────────────────────────────────────────────────────────────┐
│  서버 컴퓨터                                                    │
│                                                                │
│  ┌─────────────────┐                                           │
│  │ 네트워크 카드 1  │ ─── 192.168.1.100 (내부망)                │
│  └─────────────────┘                                           │
│                                                                │
│  ┌─────────────────┐                                           │
│  │ 네트워크 카드 2  │ ─── 203.0.113.50 (외부 인터넷)            │
│  └─────────────────┘                                           │
│                                                                │
│  ┌─────────────────┐                                           │
│  │ 루프백 (가상)    │ ─── 127.0.0.1 (자기 자신만)               │
│  └─────────────────┘                                           │
│                                                                │
│  ─────────────────────────────────────────────────────────────│
│                                                                │
│  Next.js 서버가 바인딩할 때:                                     │
│                                                                │
│  • 127.0.0.1:3000  → 루프백에서만 접속 가능 (외부 ❌)            │
│  • 192.168.1.100:3000 → 내부망에서만 접속 가능                  │
│  • 0.0.0.0:3000    → 모든 인터페이스에서 접속 가능 ✅            │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 2.4 포트 포워딩이란?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    포트 포워딩 = 전화 돌려주기                                │
└─────────────────────────────────────────────────────────────────────────────┘

회사 대표번호로 전화하면 → 내선번호로 연결해주는 것과 같음

Docker에서:
┌─────────────────────────────────────────────────────────────┐
│  호스트 (Windows)                                           │
│                                                             │
│  외부에서 localhost:3000 으로 접속                           │
│           │                                                 │
│           │  포트 포워딩 (docker-compose.yml의 ports)        │
│           ↓                                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  Docker 컨테이너                                     │   │
│  │                                                     │   │
│  │  컨테이너 내부 3000 포트로 전달                       │   │
│  │           ↓                                         │   │
│  │  Next.js 서버 (0.0.0.0:3000에서 수신 중)             │   │
│  │                                                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘

docker-compose.yml:
  ports:
    - "3000:3000"   # 호스트3000 → 컨테이너3000
    - "8080:3000"   # 호스트8080 → 컨테이너3000 (다른 포트도 가능)
```

---

## 3. Docker란 무엇인가?

### 3.1 Docker가 해결하는 문제

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      "내 컴퓨터에서는 되는데요?"                               │
└─────────────────────────────────────────────────────────────────────────────┘

문제 상황:
┌──────────────┐          ┌──────────────┐
│ 개발자 PC     │          │ 서버         │
│              │          │              │
│ Node 18      │    →     │ Node 16      │  버전 다름!
│ Windows      │          │ Linux        │  OS 다름!
│ 특정 패키지   │          │ 패키지 없음   │  의존성 다름!
└──────────────┘          └──────────────┘
        ↓                        ↓
     잘 동작함               에러 발생!

Docker 해결책:
┌──────────────┐          ┌──────────────┐
│ 개발자 PC     │          │ 서버         │
│              │          │              │
│ ┌──────────┐ │    →     │ ┌──────────┐ │
│ │ Container│ │          │ │ Container│ │  완전히 동일!
│ │ Node 18  │ │          │ │ Node 18  │ │
│ │ Linux    │ │          │ │ Linux    │ │
│ │ 모든 패키지│ │          │ │ 모든 패키지│ │
│ └──────────┘ │          │ └──────────┘ │
└──────────────┘          └──────────────┘
```

### 3.2 가상머신(VM) vs 컨테이너

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        VM vs Container 비교                                  │
└─────────────────────────────────────────────────────────────────────────────┘

가상머신 (VM):                          컨테이너 (Docker):
┌─────────────────────────┐            ┌─────────────────────────┐
│      App A    App B     │            │      App A    App B     │
├─────────────────────────┤            ├─────────────────────────┤
│   Guest OS   Guest OS   │            │  Container  Container   │
│   (Ubuntu)   (CentOS)   │  ← 무거움   │   (경량)     (경량)     │  ← 가벼움
├─────────────────────────┤            ├─────────────────────────┤
│       Hypervisor        │            │      Docker Engine      │
├─────────────────────────┤            ├─────────────────────────┤
│        Host OS          │            │        Host OS          │
├─────────────────────────┤            ├─────────────────────────┤
│        Hardware         │            │        Hardware         │
└─────────────────────────┘            └─────────────────────────┘

비유:
VM = 집을 통째로 빌림 (OS 전체 포함)
Container = 방만 빌림 (Host OS 공유)

| 항목 | VM | Container |
|------|-----|-----------|
| 시작 시간 | 분 단위 | 초 단위 |
| 메모리 | GB 단위 | MB 단위 |
| 격리 수준 | 완전 격리 | 프로세스 격리 |
| 용도 | 다른 OS 필요 시 | 앱 배포 |
```

### 3.3 Docker 핵심 개념

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Docker 핵심 3요소                                     │
└─────────────────────────────────────────────────────────────────────────────┘

1. Dockerfile (레시피)
   ─────────────────────
   "이 앱을 실행하려면 이런 것들이 필요해"

   FROM node:20-alpine     # 베이스: Node.js 환경
   WORKDIR /app            # 작업 폴더
   COPY package.json ./    # 파일 복사
   RUN npm install         # 명령 실행
   CMD ["npm", "start"]    # 시작 명령

2. Image (완성된 설계도)
   ─────────────────────
   Dockerfile을 빌드한 결과물
   읽기 전용, 공유 가능

   $ docker build -t myapp .
   # Dockerfile → Image 생성

3. Container (실행 중인 인스턴스)
   ─────────────────────
   Image를 실행한 것
   쓰기 가능, 독립적으로 동작

   $ docker run myapp
   # Image → Container 실행

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   Dockerfile  ──build──▶  Image  ──run──▶  Container           │
│   (레시피)                (빵틀)            (빵)                 │
│                                                                 │
│   하나의 Image로 여러 Container 생성 가능:                        │
│                                                                 │
│                          ┌─── Container 1                       │
│   Image ────────────────┼─── Container 2                       │
│                          └─── Container 3                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 Docker Compose란?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                  Docker Compose = 여러 컨테이너 관리 도구                      │
└─────────────────────────────────────────────────────────────────────────────┘

문제: 앱이 여러 서비스로 구성됨
- 웹 서버 (Next.js)
- 데이터베이스 (PostgreSQL)
- 캐시 (Redis)

하나씩 실행하면?
$ docker run nextjs-app
$ docker run postgres
$ docker run redis
→ 번거롭고, 네트워크 설정도 복잡

Docker Compose로 한 번에:
$ docker-compose up

# docker-compose.yml
version: '3'
services:
  web:                    # 서비스 1: 웹앱
    build: .
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis

  db:                     # 서비스 2: DB
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret

  redis:                  # 서비스 3: 캐시
    image: redis:alpine
```

---

## 4. Docker 네트워크

### 4.1 컨테이너 네트워크 격리

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     컨테이너는 격리된 네트워크를 가짐                           │
└─────────────────────────────────────────────────────────────────────────────┘

각 컨테이너는 자신만의 네트워크 공간을 가짐:

┌─────────────────────────────────────────────────────────────────┐
│  Host (Windows/Mac/Linux)                                       │
│  IP: 192.168.1.100                                              │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Docker Network (bridge: 172.17.0.0/16)                 │   │
│  │                                                         │   │
│  │  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │   │
│  │  │ Container A │    │ Container B │    │ Container C │ │   │
│  │  │ 172.17.0.2  │    │ 172.17.0.3  │    │ 172.17.0.4  │ │   │
│  │  │             │    │             │    │             │ │   │
│  │  │ localhost   │    │ localhost   │    │ localhost   │ │   │
│  │  │ = 127.0.0.1 │    │ = 127.0.0.1 │    │ = 127.0.0.1 │ │   │
│  │  │ (자기자신만) │    │ (자기자신만) │    │ (자기자신만) │ │   │
│  │  └─────────────┘    └─────────────┘    └─────────────┘ │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

핵심 포인트:
• 컨테이너 A의 localhost ≠ 컨테이너 B의 localhost
• 컨테이너 A의 localhost ≠ Host의 localhost
• 각자 독립된 네트워크 공간!
```

### 4.2 왜 0.0.0.0 바인딩이 필요한가?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      0.0.0.0 바인딩의 필요성                                  │
└─────────────────────────────────────────────────────────────────────────────┘

시나리오: Next.js를 Docker에서 실행

❌ 잘못된 경우 (127.0.0.1 바인딩):
┌─────────────────────────────────────────────────────────────────┐
│  Host (Windows)                                                 │
│                                                                 │
│  브라우저 → localhost:3000 → ??? (연결 안됨)                     │
│                                                                 │
│  ┌───────────────────────────────────────────────────┐         │
│  │  Container                                        │         │
│  │                                                   │         │
│  │  Next.js가 127.0.0.1:3000에 바인딩                │         │
│  │          ↓                                        │         │
│  │  컨테이너 내부의 루프백에서만 수신                   │         │
│  │  외부(Host)에서 접근 불가! ❌                       │         │
│  │                                                   │         │
│  └───────────────────────────────────────────────────┘         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

✅ 올바른 경우 (0.0.0.0 바인딩):
┌─────────────────────────────────────────────────────────────────┐
│  Host (Windows)                                                 │
│                                                                 │
│  브라우저 → localhost:3000 ─┐                                   │
│                            │ 포트 포워딩                        │
│                            ↓                                    │
│  ┌───────────────────────────────────────────────────┐         │
│  │  Container                                        │         │
│  │                                                   │         │
│  │  Next.js가 0.0.0.0:3000에 바인딩                  │         │
│  │          ↓                                        │         │
│  │  모든 인터페이스에서 수신                           │         │
│  │  외부(Host)에서 접근 가능! ✅                       │         │
│  │                                                   │         │
│  └───────────────────────────────────────────────────┘         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 Docker Compose 서비스 간 통신

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    서비스 이름으로 통신 (DNS 자동 설정)                         │
└─────────────────────────────────────────────────────────────────────────────┘

# docker-compose.yml
services:
  web:
    build: .
    depends_on:
      - db

  db:
    image: postgres:15

┌─────────────────────────────────────────────────────────────────┐
│  Docker Compose Network                                         │
│                                                                 │
│  ┌─────────────────┐         ┌─────────────────┐               │
│  │  web            │         │  db             │               │
│  │  (Next.js)      │         │  (PostgreSQL)   │               │
│  │                 │         │                 │               │
│  │                 │  ────▶  │                 │               │
│  │  db:5432로 접속  │         │  5432 포트 수신  │               │
│  │  (서비스 이름!)  │         │                 │               │
│  └─────────────────┘         └─────────────────┘               │
│                                                                 │
│  Docker가 자동으로 DNS 설정:                                     │
│  • "db" → 172.17.0.3 (db 컨테이너 IP)                           │
│  • "web" → 172.17.0.2 (web 컨테이너 IP)                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

// Next.js에서 DB 연결 시
const connectionString = "postgresql://user:pass@db:5432/mydb"
//                                              ↑
//                                        서비스 이름 사용!
//                                        (localhost 아님)
```

---

## 5. 웹서버와 리버스 프록시

### 5.1 웹서버(Nginx)의 역할

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         Nginx가 하는 일들                                    │
└─────────────────────────────────────────────────────────────────────────────┘

1. 정적 파일 제공 (Static File Serving)
   ─────────────────────────────────────
   HTML, CSS, JS, 이미지 등을 빠르게 전달

   브라우저 → "main.js 주세요" → Nginx → 파일 전송

2. 리버스 프록시 (Reverse Proxy)
   ─────────────────────────────────────
   요청을 받아서 백엔드 서버로 전달

   브라우저 → Nginx → Next.js/Express/Django

3. 로드 밸런싱 (Load Balancing)
   ─────────────────────────────────────
   여러 서버에 요청 분산

   브라우저 → Nginx → Server1, Server2, Server3

4. SSL/TLS 종료 (HTTPS)
   ─────────────────────────────────────
   HTTPS 암호화/복호화 처리

   브라우저 ══HTTPS══▶ Nginx ──HTTP──▶ 백엔드
            (암호화)         (내부는 평문)

5. 캐싱 (Caching)
   ─────────────────────────────────────
   자주 요청되는 데이터 저장
```

### 5.2 리버스 프록시란?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    프록시 vs 리버스 프록시                                    │
└─────────────────────────────────────────────────────────────────────────────┘

Forward Proxy (일반 프록시):
클라이언트를 대신해서 요청

사용자 → [Proxy] → 인터넷 → 서버
         ↑
     사용자 숨김 (VPN 같은 것)


Reverse Proxy (리버스 프록시):
서버를 대신해서 응답

사용자 → 인터넷 → [Nginx] → 실제 서버
                    ↑
                서버 숨김 (보안)

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  왜 리버스 프록시를 쓰는가?                                       │
│                                                                 │
│  1. 보안: 실제 서버 IP 숨김                                       │
│  2. 성능: 정적 파일은 Nginx가 직접 처리 (더 빠름)                   │
│  3. 유연성: 백엔드 서버 교체가 쉬움                                │
│  4. SSL: 인증서 관리를 한 곳에서                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 Nginx + Next.js 구성 예시

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Nginx 리버스 프록시 구성                                   │
└─────────────────────────────────────────────────────────────────────────────┘

# docker-compose.yml
version: '3'
services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"           # 외부 노출은 Nginx만!
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - web

  web:
    build: .
    expose:
      - "3000"            # 내부 네트워크에만 노출 (ports 아님!)
    # ports 없음! 외부에서 직접 접근 불가

┌─────────────────────────────────────────────────────────────────┐
│  Docker Network                                                 │
│                                                                 │
│  외부 ──:80──▶ ┌───────┐        ┌───────────┐                  │
│               │ Nginx │──:3000─▶│ Next.js   │                  │
│               │       │        │ (내부만)   │                  │
│  외부 ──:443─▶│       │        │           │                  │
│               └───────┘        └───────────┘                  │
│                  ↑                                              │
│            0.0.0.0:80 바인딩                                    │
│            (외부 접근 허용)                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

# nginx.conf
server {
    listen 80;

    location / {
        proxy_pass http://web:3000;    # 서비스 이름 사용
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 5.4 Nginx 설치 = 0.0.0.0 문제 해결?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Nginx를 쓰면 자동 해결되나?                                │
└─────────────────────────────────────────────────────────────────────────────┘

질문: "Docker에 Nginx 설치하면 0.0.0.0 바인딩 문제가 해결되나요?"

답변: 자동으로 해결되는 건 아님!

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Nginx도 바인딩이 필요함:                                        │
│                                                                 │
│  • Nginx가 0.0.0.0:80에 바인딩 (기본값이라 보통 문제없음)          │
│  • Next.js는 127.0.0.1:3000에 바인딩해도 OK                      │
│    (Nginx가 내부에서 접근하므로)                                  │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐ │
│  │  Container                                                │ │
│  │                                                           │ │
│  │  Nginx (0.0.0.0:80) ← 외부 접근 가능                       │ │
│  │      │                                                    │ │
│  │      │ proxy_pass (내부 통신)                              │ │
│  │      ↓                                                    │ │
│  │  Next.js (127.0.0.1:3000) ← 내부만 접근 가능               │ │
│  │                                                           │ │
│  └───────────────────────────────────────────────────────────┘ │
│                                                                 │
│  하지만! 현재 SwipeShop 구조 (Nginx 없음):                        │
│                                                                 │
│  Next.js가 직접 외부 요청을 받아야 함                             │
│  → 0.0.0.0 바인딩 필수!                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

정리:
• Nginx 사용 O → Next.js는 내부 바인딩만 해도 됨
• Nginx 사용 X → Next.js가 직접 0.0.0.0 바인딩 필요 (현재 상태)
```

---

## 6. 개발환경 vs 프로덕션

### 6.1 환경별 차이점

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    개발 vs 프로덕션 환경 비교                                 │
└─────────────────────────────────────────────────────────────────────────────┘

| 항목 | 개발 (Development) | 프로덕션 (Production) |
|------|-------------------|---------------------|
| 목적 | 빠른 개발/테스트 | 안정적인 서비스 운영 |
| 성능 | 느려도 OK | 최적화 필수 |
| 디버깅 | 상세 에러 표시 | 에러 숨김 (보안) |
| 핫리로드 | 필수 | 불필요 |
| 소스맵 | 포함 | 제외 (용량/보안) |
| 빌드 | 불필요 (JIT) | 필수 (AOT) |
| 이미지 크기 | 상관없음 | 최소화 |
```

### 6.2 Docker 설정 차이

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         개발용 vs 프로덕션용 Docker                           │
└─────────────────────────────────────────────────────────────────────────────┘

개발용 (Dockerfile):
━━━━━━━━━━━━━━━━━━━━
FROM node:20-alpine

WORKDIR /app
COPY package*.json ./
RUN npm install          # devDependencies 포함

COPY . .
CMD ["npm", "run", "dev"] # 개발 서버

특징:
• 모든 의존성 설치
• 소스 코드 볼륨 마운트 (핫리로드)
• 빌드 없이 바로 실행


프로덕션용 (Dockerfile.prod):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Stage 1: 빌드
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci               # 정확한 버전으로 설치
COPY . .
RUN npm run build        # 프로덕션 빌드

# Stage 2: 실행
FROM node:20-alpine AS runner
WORKDIR /app

# 보안: 일반 유저로 실행
RUN adduser --system --uid 1001 nextjs
USER nextjs

# 빌드 결과물만 복사
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/public ./public

CMD ["node", "server.js"]

특징:
• 멀티스테이지 빌드 (이미지 크기 최소화)
• 실행에 필요한 파일만 포함
• 보안 강화 (non-root)
```

### 6.3 이미지 크기 비교

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         이미지 크기 최적화                                    │
└─────────────────────────────────────────────────────────────────────────────┘

개발용 이미지:
┌─────────────────────────────────────────────┐
│  node:20-alpine (베이스)        ~180MB      │
│  node_modules (전체)            ~300MB      │
│  소스 코드                       ~10MB      │
│  ─────────────────────────────────────────  │
│  총합                           ~500MB      │
└─────────────────────────────────────────────┘

프로덕션용 이미지 (멀티스테이지):
┌─────────────────────────────────────────────┐
│  node:20-alpine (베이스)        ~180MB      │
│  standalone 빌드 결과물만        ~30MB      │
│  ─────────────────────────────────────────  │
│  총합                           ~210MB      │
└─────────────────────────────────────────────┘

절감: 약 60% 감소!
```

---

## 7. DevOps 기초 개념

### 7.1 DevOps란?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DevOps = Development + Operations                         │
└─────────────────────────────────────────────────────────────────────────────┘

전통적 방식:
┌─────────────┐                    ┌─────────────┐
│  개발팀      │  ── 코드 던지고 ──▶ │  운영팀      │
│ (Dev)       │     끝!            │ (Ops)       │
│             │                    │             │
│ "코드 완성!" │                    │ "배포 실패!" │
└─────────────┘                    └─────────────┘
        ↓                                 ↓
   책임 분리                          서로 비난
   (사일로)                           (갈등)


DevOps 방식:
┌─────────────────────────────────────────────┐
│              DevOps 팀                       │
│                                             │
│  개발 ←──────── 협업 ──────────▶ 운영        │
│                                             │
│  • 같은 도구 사용 (Docker, K8s)              │
│  • 자동화된 파이프라인                        │
│  • 빠른 피드백 루프                          │
│                                             │
└─────────────────────────────────────────────┘
```

### 7.2 CI/CD 파이프라인

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CI/CD 파이프라인                                     │
└─────────────────────────────────────────────────────────────────────────────┘

CI (Continuous Integration, 지속적 통합):
코드 변경 시 자동으로 빌드/테스트

CD (Continuous Deployment, 지속적 배포):
테스트 통과 시 자동으로 배포

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  개발자 ─push─▶ GitHub ─trigger─▶ CI/CD Pipeline                │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  CI Pipeline                                            │   │
│  │                                                         │   │
│  │  1. 코드 체크아웃                                        │   │
│  │      ↓                                                  │   │
│  │  2. 의존성 설치 (npm install)                            │   │
│  │      ↓                                                  │   │
│  │  3. 린트 검사 (npm run lint)                             │   │
│  │      ↓                                                  │   │
│  │  4. 타입 검사 (tsc --noEmit)                             │   │
│  │      ↓                                                  │   │
│  │  5. 테스트 실행 (npm test)                               │   │
│  │      ↓                                                  │   │
│  │  6. 빌드 (npm run build)                                 │   │
│  │      ↓                                                  │   │
│  │  7. Docker 이미지 생성                                   │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          ↓                                      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  CD Pipeline                                            │   │
│  │                                                         │   │
│  │  8. 이미지 레지스트리에 푸시                              │   │
│  │      ↓                                                  │   │
│  │  9. 스테이징 환경 배포                                   │   │
│  │      ↓                                                  │   │
│  │  10. 통합 테스트                                         │   │
│  │      ↓                                                  │   │
│  │  11. 프로덕션 배포                                       │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3 인프라 구성 요소

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       인프라 구성 요소 정리                                   │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  클라우드 인프라 (AWS 기준)                                       │
│                                                                 │
│  1. 컴퓨팅                                                       │
│     • EC2: 가상 서버                                             │
│     • ECS/EKS: 컨테이너 오케스트레이션                            │
│     • Lambda: 서버리스 함수                                      │
│                                                                 │
│  2. 네트워크                                                     │
│     • VPC: 가상 네트워크                                         │
│     • ALB: 로드밸런서                                            │
│     • Route53: DNS                                              │
│     • CloudFront: CDN                                           │
│                                                                 │
│  3. 스토리지                                                     │
│     • S3: 파일 저장                                              │
│     • EBS: 블록 스토리지                                         │
│                                                                 │
│  4. 데이터베이스                                                  │
│     • RDS: 관계형 DB (PostgreSQL, MySQL)                         │
│     • DynamoDB: NoSQL                                           │
│     • ElastiCache: Redis/Memcached                              │
│                                                                 │
│  5. 모니터링                                                     │
│     • CloudWatch: 로그/메트릭                                    │
│     • X-Ray: 분산 추적                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. 자주 묻는 질문

### Q1: localhost와 127.0.0.1의 차이?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    localhost vs 127.0.0.1                                   │
└─────────────────────────────────────────────────────────────────────────────┘

기본적으로 같지만, 미묘한 차이가 있음:

localhost:
• 호스트 파일 또는 DNS로 해석
• IPv4 (127.0.0.1) 또는 IPv6 (::1)로 변환될 수 있음
• OS 설정에 따라 다름

127.0.0.1:
• 명시적인 IPv4 루프백 주소
• 해석 과정 없이 바로 사용

문제 상황:
┌─────────────────────────────────────────────────────────────────┐
│  서버: 127.0.0.1:3000에서 수신 중 (IPv4만)                       │
│  브라우저: localhost:3000 접속 → ::1:3000으로 해석 (IPv6)        │
│  결과: 연결 안됨!                                                │
└─────────────────────────────────────────────────────────────────┘

해결책:
• 서버에서 0.0.0.0으로 바인딩 (IPv4 + IPv6 모두 수신)
• 또는 명시적으로 127.0.0.1 사용
```

### Q2: Docker Desktop이 느린 이유?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Windows에서 Docker가 느린 이유                            │
└─────────────────────────────────────────────────────────────────────────────┘

원인: 파일 시스템 성능

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Windows 파일 (NTFS)                                            │
│       ↓                                                         │
│  WSL2 변환 레이어 ← 병목!                                        │
│       ↓                                                         │
│  Linux 파일 시스템 (ext4)                                        │
│       ↓                                                         │
│  Docker 컨테이너                                                 │
│                                                                 │
│  볼륨 마운트 시 이 변환이 매번 발생                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

해결책:
1. WSL2 내부에 프로젝트 두기 (\\wsl$\Ubuntu\home\...)
2. 볼륨 마운트 최소화
3. node_modules는 컨테이너 내부에 (볼륨 분리)
```

### Q3: expose vs ports 차이?

```yaml
# docker-compose.yml

services:
  web:
    # ports: 호스트에 포트 노출 (외부 접근 가능)
    ports:
      - "3000:3000"

  db:
    # expose: 컨테이너 네트워크 내부에만 노출
    expose:
      - "5432"
```

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ports vs expose                                      │
└─────────────────────────────────────────────────────────────────────────────┘

ports:
• 호스트 ↔ 컨테이너 포트 매핑
• 외부에서 접근 가능
• 예: 웹 서버, API 서버

expose:
• 컨테이너 간 통신용
• 외부에서 직접 접근 불가
• 예: 데이터베이스 (보안상 외부 노출 X)

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  외부 (브라우저)                                                 │
│       │                                                         │
│       │ ✅ ports: "3000:3000"                                   │
│       ↓                                                         │
│  ┌─────────┐         ┌─────────┐                               │
│  │   web   │ ──────▶ │   db    │                               │
│  │ :3000   │ expose  │ :5432   │ ← 외부 접근 ❌                 │
│  └─────────┘ :5432   └─────────┘                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Q4: 이미지와 컨테이너 삭제 방법?

```bash
# 실행 중인 컨테이너 확인
docker ps

# 모든 컨테이너 확인 (중지된 것 포함)
docker ps -a

# 컨테이너 중지
docker stop [컨테이너ID]

# 컨테이너 삭제
docker rm [컨테이너ID]

# 이미지 목록
docker images

# 이미지 삭제
docker rmi [이미지ID]

# 사용하지 않는 것들 정리 (주의!)
docker system prune -a
```

### Q5: 환경변수는 어디에 설정?

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         환경변수 설정 위치                                    │
└─────────────────────────────────────────────────────────────────────────────┘

우선순위 (높은 순):
1. docker-compose.yml의 environment
2. .env 파일
3. Dockerfile의 ENV
4. 이미지의 기본값

# .env 파일 (버전 관리 X, .gitignore에 추가)
DATABASE_URL=postgresql://user:pass@db:5432/mydb
API_KEY=secret123

# docker-compose.yml
services:
  web:
    env_file:
      - .env           # 파일에서 읽기
    environment:
      - NODE_ENV=production  # 직접 지정
      - API_KEY=${API_KEY}   # 변수 참조

# Dockerfile
ENV NODE_ENV=production
```

---

## 용어 정리 (빠른 참조)

| 용어 | 설명 |
|------|------|
| **바인딩** | 서버가 특정 IP:포트에서 연결을 수신하겠다고 선언 |
| **포트 포워딩** | 외부 포트를 내부 포트로 연결 |
| **리버스 프록시** | 클라이언트 요청을 받아 백엔드 서버로 전달 |
| **로드밸런싱** | 여러 서버에 트래픽 분산 |
| **컨테이너** | 격리된 실행 환경 (Docker) |
| **이미지** | 컨테이너를 만들기 위한 템플릿 |
| **볼륨** | 컨테이너에 연결된 영구 저장소 |
| **CI/CD** | 자동화된 빌드/테스트/배포 파이프라인 |
| **오케스트레이션** | 여러 컨테이너 관리 (Kubernetes) |

---

**작성자**: Claude Code
**최종 수정**: 2026-01-28
